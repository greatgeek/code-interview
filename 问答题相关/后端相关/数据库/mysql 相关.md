# mysql 相关

## 基础篇

### 执行一条 select 语句，期间发生了什么？

![查询语句执行流程](mysql 相关.assets/mysql查询流程.png)

MySQL 的架构分为两层：Server 层和存储引擎层。

* Server 层负责建立连接、分析和执行 SQL。MySQL 大多数核心功能模块都在这层实现，包括连接器、查询缓存、解析器、预处理器、优化器、执行器等。另外所有内置函数（如时间、日期）和跨存储引擎的功能（如存储过程、触发器、视图等）都在 Server 层实现。
* 存储引擎层负责数据的存储和提取。支持 InnoDB 等若干 个存储引擎，不同的存储引擎共用一个 Server 层。默认存储引擎为 InnoDB，支持索引类型为 B+树，在数据表中创建的主键索引和二级索引默认使用的是 B+树索引。

#### 第一步：连接器

MySQL 的基于 TCP 协议进行传输，因此会通过 TCP 的三次握手进行建立连接。空闲连接会因为超时被关闭（默认为 8 小时）。max_connections 参数决定最大连接数。

长连接与短连接（概念与 HTTP 类似）：

短连接是执行完一条 SQL 语句后断开，长连接为执行完 SQL 语句后保持连接供下次使用。

长连接可以减少建立连接和断开连接的过程，但会随着连接时长的增加占用内存会增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象只有在连接断开时才会释放。

**怎么解决长连接占用内存的问题？**

1. 定期断开长连接。既然断开连接后就会释放连接占用的内存资源，那么可以定期断开长连接后再新建连接。
2. 客户端主动重置连接。MySQL 5.7 版本实现了 `mysql_reset_connection()`函数的接口，注意这是接口不是命令，当客户端执行了一个很大的操作后，在代码里调用`mysql_reset_connection`函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完的状态。

#### 第二步：查询缓存

连接器连接完成后，客户端就会向 MySQL 服务器发送 SQL 语句了，MySQL 服务器会根据语句的第一个字段来决定这是个什么类型的语句。

若是查询语句（select 语句），MySQL 服务器会先去查询缓存（Query Cache）里查找缓存数据。查询缓存的数据结构为 key-value形式，key 为 SQL 查询语句，value 为 SQL 语句的查询结果。

对于更新频繁的表，查询缓存的命中率很低。因为只要一个字段有更新操作，那么这个表的查询缓存就会被清空。因此 MySQL 8.0 版本直接将查询缓存删掉了。

#### 第三步：解析 SQL

解析器会对 SQL 语句做词法分析与语法分析。如果语句有语法问题，会在这个阶段被拦住。

#### 第四步：执行 SQL

执行分为三个阶段：1.预处理阶段（prepare）；2.优化阶段（optimize）；3.执行阶段（execute）；

1.预处理阶段

* 检查 SQL 语句中的涉及的表和字段是否存在；
* 将 `*`扩展为表的所有列；

2.优化器

* 将 SQL 查询语句的执行方案确定下来，如决定选择哪个索引。

3.执行器

执行器会与存储引擎交互。

* 主键索引查询
* 全表扫描
* 索引下推
  * 索引下推能够减少二级索引在查询时的回表操作，提高查询效率。

>### 索引下推（Index Condition Pushdown）
>
>索引下推是数据库优化器的一个优化策略，用于提高查询性能。在普通索引扫描中，数据库系统会首先通过索引找到符合条件的记录，然后再通过回表操作获取相应的行数据，最后应用其他的过滤条件。而在索引下推优化中，一部分能在索引层就解决的过滤条件会被“推”到存储引擎层，这样可以减少不必要的数据读取和回表操作。
>
>例如，假设有一个带有 `(id, age)` 索引的 `users` 表，你想查询 `id > 100` 且 `age > 18` 的记录。在索引下推优化中，`age > 18` 这个条件可以直接在索引扫描过程中应用，而不需要先获取所有 `id > 100` 的记录然后再过滤 `age > 18`。

>### 回表操作（Lookup）
>
>回表操作是在利用非聚簇索引（或称为二级索引、辅助索引）进行查询时可能会出现的一个步骤。当索引不包含查询所需的所有信息时，数据库系统需要通过索引中的指针回到主表（聚簇索引表）中查找完整的行数据。
>
>例如，假设有一个 `students` 表，主键是 `student_id`，并有一个非聚簇索引是 `(first_name, last_name)`。如果你要查询所有名为 "John" 的学生的所有信息，那么数据库首先会使用 `(first_name, last_name)` 索引找到所有符合条件的记录，然后它需要“回表”到主表中，通过 `student_id` 获取这些学生的其他信息。
>
>在进行回表操作时，IO成本和CPU使用率通常会增加，因此在数据库设计和查询优化时，通常会尽量减少回表操作。

## 索引篇

索引的分类

按数据结构分类：B+树索引、Hash 索引、Full-text 索引。

按物理存储分类：聚簇索引（主键索引）、二级索引（辅助索引）。

按字段特性分类：主键索引、唯一索引、普通索引、前缀索引。

按字段个数分类：单列索引、联合索引。

在数据库系统（特别是关系数据库管理系统，如 MySQL）中，"聚簇索引"（Clustered Index）是一种特殊类型的索引，它会改变数据表中行的物理存储顺序。在聚簇索引中，索引的逻辑顺序和行的物理存储顺序相同，这就意味着表数据实际上是按照索引的顺序来存储的。

当一个表被定义时，如果有指定主键（Primary Key），则该主键默认会被用作聚簇索引的索引键。也就是说，数据表中的记录会根据主键值的顺序来进行存储。这种设置通常有助于加速基于主键的数据检索和排序操作。

以 MySQL 的 InnoDB 存储引擎为例，如果你没有显式地指定一个主键，InnoDB 引擎会尝试找一个唯一非空索引作为聚簇索引，如果也没有这样的索引，它会生成一个隐藏的聚簇索引。

创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：

* 如果有主键，则默认会使用主键作为聚簇索引的索引键；
* 如果没有主键，则选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；
* 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 作为聚簇索引的索引键；

除了聚簇索引，其他索引都属于辅助索引，也被称为二级索引或非聚簇索引。**创建的主键索引和二级索引默认使用的是 B+Tree 索引**。

### 如何理解 B+树索引？

B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是**按主键顺序存放**的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。

数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I/O 操作。

B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以**B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。**

主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：

- 主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
- 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

### 什么是回表？

使用二级索引时，MySQL会先检索二级索引中的 B+树 的索引值，找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+树查询到对应的叶子节点，然后获取整行数据。这个过程叫回表，“回”的是主键索引的表。

### 什么是覆盖索引？

当查询的数据能在二级索引的 B+树的叶子节点里查询到时，例如主键值。此时就不同再查询主键索引。**这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据**。

### 为什么 MySQL InnoDB 选择 B+树作为索引的数据结构？

***1、B+Tree vs B Tree***

B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。

另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。

***2、B+Tree vs 二叉树***

对于有 N 个叶子节点的 B+Tree，其搜索复杂度为`O(logdN)`，其中 d 表示节点允许的最大子节点个数为 d 个。

在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。

而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 `O(logN)`，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。

***3、B+Tree vs Hash***

Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。

但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。

### 有什么优化索引的方法？

* 前缀索引优化；
* 覆盖索引优化；
  * 使用联合索引，使得索引覆盖了要查询的字段，不用回表。
* 主键索引最好是自增的；
* 防止索引失效；
  * 索引失效的情况：
    * 当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
    * 当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；
    * 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
    * 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

常见扫描类型的**执行效率从低到高的顺序为**：

- All（全表扫描）；
- index（全索引扫描）；
- range（索引范围扫描）；
- ref（非唯一索引扫描）；
- eq_ref（唯一索引扫描）；
- const（结果只有一条的主键或唯一索引扫描）。

![img](mysql 相关.assets/索引总结.drawio.png)

## 事务篇

事务的 4 个特性：1.原子性（**Atomicity**）；2.一致性（**Consistency**）；3.隔离性（**Isolation**）；4.持久性（**Durability**）；

InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？

- 持久性是通过 redo log （重做日志）来保证的；
- 原子性是通过 undo log（回滚日志） 来保证的；
- 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
- 一致性则是通过持久性+原子性+隔离性来保证；

### 并行事务会引起什么问题？

MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。

那么**在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题**。

脏读：读到其他事务未提交的数据；

不可重复读：在一个事务内，前后读取的数据不一致；

幻读：前后读取的记录数量不一致；

MySQL 的四种隔离级别：1.读未提交；2.读提交；3.可重复读；4.串行化；

**MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象**，解决方案有以下两种：

- 针对**快照读**（普通 select 语句），是**通过 MVCC 方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
- 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

## 锁篇

根据加锁的范围可分为**全局锁、表级锁和行锁**三类。

