# Go 语言相关

## 协程

### 基本概念

1）进程：应用程序的启动实例，每个进程有独立的内存空间，进程间通过 IPC 通信；

2）线程：从属于于进程，CPU 的调度的基本单位；

3）协程：不受操作系统调度，协程调度器由用户应用程序提供；

### 线程模型（用户线程：内核线程）

1）N:1

2）1:1

3）M:N

### Go 调度器模型

M machine 内核线程；P processor 调度器；G goroutine 协程；

![image-20230905130256995](Go语言相关.assets/image-20230905130256995.png)

M 要持有 P 才可以执行代码。

1）P 会周期性地看全局 GRQ，防止 GRQ 中的 G 被“饿死”；

2）M 产生系统调用阻塞时会释放 P；

3）工作量窃取，当某个处理器 P 没有需要调度的 G 时，将从其他 P 中偷取 G；

## Go 垃圾回收

### 垃圾回收算法

1）引用计数，Python

优：对象可很快被回收，不会 STW；缺：循环引用难处理

2）标记-清除，Go，三色标记法

优：不需要处理循环引用；缺：STW

3）分代收集，Java

优：回收性能好；缺：算法复杂

### 垃圾回收原理

垃圾回收开始时以 root 对象（栈空间）扫描，把 root 对象引用的内存标记为“被引用”，递归地进行标记，只保留标记的内存，未被标记的内存全部标记为未分配，即完成回收。

1）三色标记法（可达性标记）

初始状态下所有对象都是白色，接着将 root 对象引用的对象置成灰对象，再递归分析，将灰对象所引用的对象置灰，其本身置黑。最终灰色队列为空，黑对象会被保留下来，白对象会被回收。

2）垃圾回收优化

1. 写屏障（write Barrier）

STW 的目的是防止 GC 扫描时内存变化，因此停止 go routine。

写屏障的目的是让 go routine 与 GC 同时运行的手段，写屏障开启，GC 过程中新分配的内存会被立即 标记，不会被本轮 GC 回收。

2. 辅助 GC

在 GC 执行过程中，如果 go routine 需要分配内存，那么 该 go routine 会参与一部分 GC 的 工作。

3）GC 触发

1. 阈值触发：阈值 = 上次 GC 内存分配量 * 内存增长率
2. 定期触发：最长 2 min
3. Runtime.GC()



## Go 并发控制

Go 提供了三种解决方案：1. Channel, 2.WaitGroup, 3. Context

## 内存逃逸

在Go语言中，内存逃逸（Memory Escape）是一个编译器优化相关的概念，主要涉及变量存储的位置：栈（Stack）还是堆（Heap）。

#### 基础概念：

1. **栈内存**: 栈内存用于存储函数调用和局部变量。它是临时的，当函数返回时，栈内存会被自动清理。
2. **堆内存**: 堆用于存储需要在函数调用之间持久存在的数据。

#### 何时会发生内存逃逸

* **返回局部变量的指针**: 如果一个函数返回了局部变量的地址，那么这个局部变量就不能存储在栈上，因为它的生命周期超过了函数本身。

```go
func foo() *int {
    x := 1
    return &x // x escapes to heap
}
```

* **将局部变量传给全局变量**: 如果局部变量的地址或引用被传给了全局变量，它也会逃逸到堆。

```go
var global *int

func bar() {
    x := 2
    global = &x // x escapes to heap
}
```

* **在闭包中引用局部变量**: 如果一个局部变量在闭包中被引用，它也将逃逸到堆，因为闭包可能在函数返回后仍然存在。

```go
func closure() func() int {
    x := 3
    return func() int { // x escapes to heap
        return x
    }
}
```

#### 如何检测内存逃逸

```go
go build -gcflags="-m" your_file.go
```

#### 为什么需要关心内存逃逸

- **性能**: 存储在堆上的变量需要垃圾收集，这会影响性能。
- **优化**: 了解内存逃逸有助于你编写更高效的代码。